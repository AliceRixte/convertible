<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"
><TITLE
>Database.HDBC</TITLE
><LINK HREF="haddock.css" REL="stylesheet" TYPE="text/css"
><SCRIPT SRC="haddock.js" TYPE="text/javascript"
></SCRIPT
></HEAD
><BODY
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="topbar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><IMG SRC="haskell_icon.gif" WIDTH="16" HEIGHT="16" ALT=" "
></TD
><TD CLASS="title"
>Haskell Database Connectivity (HDBC)</TD
><TD CLASS="topbut"
><A HREF="index.html"
>Contents</A
></TD
><TD CLASS="topbut"
><A HREF="doc-index.html"
>Index</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="modulebar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><FONT SIZE="6"
>Database.HDBC</FONT
></TD
><TD ALIGN="right"
><TABLE CLASS="narrow" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="infohead"
>Portability</TD
><TD CLASS="infoval"
>portable</TD
></TR
><TR
><TD CLASS="infohead"
>Stability</TD
><TD CLASS="infoval"
>provisional</TD
></TR
><TR
><TD CLASS="infohead"
>Maintainer</TD
><TD CLASS="infoval"
>John Goerzen &lt;jgoerzen@complete.org&gt;</TD
></TR
></TABLE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="section4"
><B
>Contents</B
></TD
></TR
><TR
><TD
><DL
><DT
><A HREF="#1"
>Introduction
</A
></DT
><DD
><DL
><DT
><A HREF="#2"
>Features
</A
></DT
><DT
><A HREF="#3"
>Available Drivers
</A
></DT
></DL
></DD
><DT
><A HREF="#4"
>Typing of transfer data
</A
></DT
><DT
><A HREF="#5"
>Database Connections
</A
></DT
><DD
><DL
><DT
><A HREF="#6"
>Preparing Queries
</A
></DT
><DT
><A HREF="#7"
>Transaction Handling
</A
></DT
><DT
><A HREF="#8"
>Connection Inquiries
</A
></DT
></DL
></DD
><DT
><A HREF="#9"
>Statements
</A
></DT
><DD
><DL
><DT
><A HREF="#10"
>Execution
</A
></DT
><DT
><A HREF="#11"
>Fetching Results
</A
></DT
><DT
><A HREF="#12"
>Statement Inquires
</A
></DT
><DT
><A HREF="#13"
>Miscellaneous
</A
></DT
></DL
></DD
><DT
><A HREF="#14"
>Exceptions
</A
></DT
><DT
><A HREF="#15"
>Column Types
</A
></DT
><DT
><A HREF="#16"
>Threading
</A
></DT
><DT
><A HREF="#17"
>Copyright and License
</A
></DT
></DL
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Description</TD
></TR
><TR
><TD CLASS="doc"
><P
>Welcome to HDBC, the Haskell Database Connectivity library.
</P
><P
>Written by John Goerzen, jgoerzen@complete.org
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Synopsis</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>class</SPAN
> Show a =&gt; <A HREF="#t%3ASqlType"
>SqlType</A
> a  <SPAN CLASS="keyword"
>where</SPAN
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="#v%3AtoSql"
>toSql</A
> :: a -&gt; <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AfromSql"
>fromSql</A
> :: <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
> -&gt; a</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AnToSql"
>nToSql</A
> :: Integral a =&gt; a -&gt; <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AiToSql"
>iToSql</A
> :: Int -&gt; <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
> <A HREF="#t%3ASqlValue"
>SqlValue</A
> </TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
>= <A HREF="#v%3ASqlString"
>SqlString</A
> String</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlWord32"
>SqlWord32</A
> Word32</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlWord64"
>SqlWord64</A
> Word64</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlInt32"
>SqlInt32</A
> Int32</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlInt64"
>SqlInt64</A
> Int64</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlInteger"
>SqlInteger</A
> Integer</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlChar"
>SqlChar</A
> Char</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlBool"
>SqlBool</A
> Bool</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlDouble"
>SqlDouble</A
> Double</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlRational"
>SqlRational</A
> Rational</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlEpochTime"
>SqlEpochTime</A
> Integer</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlTimeDiff"
>SqlTimeDiff</A
> Integer</TD
></TR
><TR
><TD CLASS="decl"
>| <A HREF="#v%3ASqlNull"
>SqlNull</A
></TD
></TR
></TABLE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
> <A HREF="#t%3AConnection"
>Connection</A
> </TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Adisconnect"
>disconnect</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO ()</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Aclone"
>clone</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Arun"
>run</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String -&gt; [<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>] -&gt; IO Integer</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsRun"
>sRun</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String -&gt; [Maybe String] -&gt; IO Integer</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Aprepare"
>prepare</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String -&gt; IO <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AquickQuery"
>quickQuery</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String -&gt; [<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>] -&gt; IO [[<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>]]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Acommit"
>commit</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO ()</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Arollback"
>rollback</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO ()</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AwithTransaction"
>withTransaction</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; (<A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO a) -&gt; IO a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AhdbcDriverName"
>hdbcDriverName</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AhdbcClientVer"
>hdbcClientVer</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AproxiedClientName"
>proxiedClientName</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AproxiedClientVer"
>proxiedClientVer</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AdbServerVer"
>dbServerVer</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AdbTransactionSupport"
>dbTransactionSupport</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; Bool</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetTables"
>getTables</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO [String]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AdescribeTable"
>describeTable</A
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String -&gt; IO [(String, <A HREF="Database-HDBC-ColTypes.html#t%3ASqlColDesc"
>SqlColDesc</A
>)]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
> <A HREF="#t%3AStatement"
>Statement</A
> </TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Aexecute"
>execute</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; [<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>] -&gt; IO Integer</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsExecute"
>sExecute</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; [Maybe String] -&gt; IO Integer</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AexecuteMany"
>executeMany</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; [[<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>]] -&gt; IO ()</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsExecuteMany"
>sExecuteMany</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; [[Maybe String]] -&gt; IO ()</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AfetchRow"
>fetchRow</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO (Maybe [<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>])</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AfetchRowAL"
>fetchRowAL</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO (Maybe [(String, <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>)])</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AfetchRowMap"
>fetchRowMap</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO (Maybe (Map String <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>))</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsFetchRow"
>sFetchRow</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO (Maybe [Maybe String])</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AfetchAllRows"
>fetchAllRows</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [[<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>]]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AfetchAllRowsAL"
>fetchAllRowsAL</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [[(String, <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>)]]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AfetchAllRowsMap"
>fetchAllRowsMap</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [Map String <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsFetchAllRows"
>sFetchAllRows</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [[Maybe String]]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AgetColumnNames"
>getColumnNames</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [String]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AdescribeResult"
>describeResult</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [(String, <A HREF="Database-HDBC-ColTypes.html#t%3ASqlColDesc"
>SqlColDesc</A
>)]</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Afinish"
>finish</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO ()</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AoriginalQuery"
>originalQuery</A
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
> <A HREF="#t%3ASqlError"
>SqlError</A
>  = <A HREF="#v%3ASqlError"
>SqlError</A
> {<TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="recfield"
><A HREF="#v%3AseState"
>seState</A
> :: String</TD
></TR
><TR
><TD CLASS="recfield"
><A HREF="#v%3AseNativeError"
>seNativeError</A
> :: Int</TD
></TR
><TR
><TD CLASS="recfield"
><A HREF="#v%3AseErrorMsg"
>seErrorMsg</A
> :: String</TD
></TR
></TABLE
>}</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AcatchSql"
>catchSql</A
> :: IO a -&gt; (<A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
> -&gt; IO a) -&gt; IO a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AhandleSql"
>handleSql</A
> :: (<A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
> -&gt; IO a) -&gt; IO a -&gt; IO a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AsqlExceptions"
>sqlExceptions</A
> :: Exception -&gt; Maybe <A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AhandleSqlError"
>handleSqlError</A
> :: IO a -&gt; IO a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
>module <A HREF="Database-HDBC-ColTypes.html"
>Database.HDBC.ColTypes</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="1"
>Introduction
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Welcome to HDBC, Haskell Database Connectivity.
</P
><P
>HDBC provides an abstraction layer between Haskell programs and SQL
relational databases.  This lets you write database code once, in
Haskell, and have it work with any number of backend SQL databases
(MySQL, Oracle, PostgreSQL, ODBC-compliant databases, etc.)
</P
><P
>HDBC is modeled loosely on Perl's DBI interface
<A HREF="http://search.cpan.org/~timb/DBI/DBI.pm"
>http://search.cpan.org/~timb/DBI/DBI.pm</A
>, though it has also
been influenced by Python's DB-API v2, JDBC in Java, and HSQL in
Haskell.
</P
><P
>HDBC is a from-scratch effort.  It is not a reimplementation of HSQL,
though its purpose is the same.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="2"
>Features
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Features of HDBC include:
</P
><UL
><LI
> Ability to use replacable parameters to let one query be
   executed multiple times (eliminates the need for an escape
   function)
</LI
><LI
> Ability to access returned rows by column number
</LI
><LI
> Ability to read data from the SQL server on-demand rather than
   reading the entire result set up front
</LI
><LI
> HUnit testsuite for each backend driver
</LI
><LI
> Well-defined standard API and easy backend driver implementation
</LI
><LI
> Lazy reading of the entire result set (think hGetContents, but
   for the results of SELECT) (see <TT
><A HREF="Database-HDBC.html#v%3AsFetchAllRows"
>sFetchAllRows</A
></TT
>)
</LI
><LI
> Support for translation between Haskell and SQL types
</LI
><LI
> Support for querying database server properties
</LI
><LI
> Add-on package (hdbc-missingh) to integrate with MissingH,
   providing a database backend for AnyDBM.
</LI
><LI
> Support for querying metadata such as column names.
</LI
></UL
><P
>Features on the TODO list which will appear shortly include:
</P
><UL
><LI
> Support for querying additional metadata (column types, etc.)
</LI
></UL
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="3"
>Available Drivers
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Here is a list of known drivers as of March 2, 2005:
</P
><DL
><DT
><TT
>Sqlite v3</TT
></DT
><DD
> Available from <A HREF="http://quux.org/devel/hdbc"
>http://quux.org/devel/hdbc</A
>.  Or, to
participate in development, use 
<TT
>darcs get --partial <A HREF="http://darcs.complete.org/hdbc-sqlite3"
>http://darcs.complete.org/hdbc-sqlite3</A
></TT
>
</DD
><DT
><TT
>PostgreSQL</TT
></DT
><DD
> Available from <A HREF="http://quux.org/devel/hdbc"
>http://quux.org/devel/hdbc</A
>.  Or, to
participate in development, use
<TT
>darcs get --partial <A HREF="http://darcs.complete.org/hdbc-postgresql"
>http://darcs.complete.org/hdbc-postgresql</A
></TT
>
</DD
><DT
><TT
>ODBC</TT
></DT
><DD
> Available from <A HREF="http://quux.org/devel/hdbc"
>http://quux.org/devel/hdbc</A
>.  Or, to
partitipace in development, use
<TT
>darcs get --partial <A HREF="http://darcs.complete.org/hdbc-odbc"
>http://darcs.complete.org/hdbc-odbc</A
></TT
>
</DD
></DL
><P
>In addition, there is one integration package: <EM
>hdbc-missingh</EM
>.  This
integrates with the MissingH library <A HREF="http://quux.org/devel/missingh"
>http://quux.org/devel/missingh</A
>.
Among other things, it lets any HDBC database act as a backend for the
AnyDBM interface.  Available from <A HREF="http://quux.org/devel/hdbc"
>http://quux.org/devel/hdbc</A
>.  Or,
to participate in development, use
<TT
>darcs get --partial <A HREF="http://darcs.complete.org/hdbc-missingh"
>http://darcs.complete.org/hdbc-missingh</A
></TT
>
</P
><P
>The latest version of HDBC itself is available from
<A HREF="http://quux.org/devel/hdbc"
>http://quux.org/devel/hdbc</A
>.  Or, to participate in development, use
<TT
>darcs get --partial <A HREF="http://darcs.complete.org/hdbc"
>http://darcs.complete.org/hdbc</A
></TT
>.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="4"
>Typing of transfer data
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>class</SPAN
> Show a =&gt; <A NAME="t%3ASqlType"
></A
><B
>SqlType</B
> a  <SPAN CLASS="keyword"
>where</SPAN
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><P
>Conversions to and from <TT
><A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TT
>s and standard Haskell types.
</P
><P
>Conversions are powerful; for instance, you can call <TT
><A HREF="Database-HDBC.html#v%3AfromSql"
>fromSql</A
></TT
> on a SqlInt32
and get a String or a Double out of it.  This class attempts to Do
The Right Thing whenever possible, and will raise an error when asked to
do something incorrect.  In particular, when converting to any type
except a Maybe, <TT
><A HREF="Database-HDBC.html#v%3ASqlNull"
>SqlNull</A
></TT
> as the input will cause an error to be raised.
</P
><P
>Here are some notes about conversion:
</P
><UL
><LI
> Fractions of a second are not preserved on time values
</LI
></UL
><P
>See also <TT
><A HREF="Database-HDBC.html#v%3AnToSql"
>nToSql</A
></TT
>, <TT
><A HREF="Database-HDBC.html#v%3AiToSql"
>iToSql</A
></TT
>.
</P
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="section4"
>Methods</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A NAME="v%3AtoSql"
></A
><B
>toSql</B
> :: a -&gt; <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AfromSql"
></A
><B
>fromSql</B
> :: <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
> -&gt; a</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:SqlType')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:SqlType" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> Bool</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> CalendarTime</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> Char</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> ClockTime</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> Double</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> Int</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> Int32</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> Int64</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> Integer</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> Rational</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> String</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> TimeDiff</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> Word32</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> Word64</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> a =&gt; <A HREF="Database-HDBC.html#t%3ASqlType"
>SqlType</A
> (Maybe a)</TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AnToSql"
></A
><B
>nToSql</B
> :: Integral a =&gt; a -&gt; <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TD
></TR
><TR
><TD CLASS="doc"
>Converts any Integral type to a <TT
><A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TT
> by using toInteger. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AiToSql"
></A
><B
>iToSql</B
> :: Int -&gt; <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TD
></TR
><TR
><TD CLASS="doc"
>Convenience function for using numeric literals in your program. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
> <A NAME="t%3ASqlValue"
></A
><B
>SqlValue</B
> </TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><P
>The main type for expressing Haskell values to SQL databases.
</P
><P
>This type is used to marshall Haskell data to and from database APIs.
HDBC driver interfaces will do their best to use the most accurate and
efficient way to send a particular value to the database server.
</P
><P
>Values read back from the server are put in the most appropriate <TT
><A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TT
>
type.  <TT
><A HREF="Database-HDBC.html#v%3AfromSql"
>fromSql</A
></TT
> can then be used to convert them into whatever type
is needed locally in Haskell.
</P
><P
>Most people will use <TT
><A HREF="Database-HDBC.html#v%3AtoSql"
>toSql</A
></TT
> and <TT
><A HREF="Database-HDBC.html#v%3AfromSql"
>fromSql</A
></TT
> instead of manipulating
<TT
><A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TT
>s directly.
</P
><P
>The default representation of time values is an integer number of seconds.
Databases such as PostgreSQL with builtin timestamp types can will see
automatic conversion between these Haskell types to local types.  Other
databases can just use an int or a string. 
</P
><P
>This behavior also exists for other types.  For instance, many databases don't
have a Rational type, so they'll just use Haskell's show function and
store a Rational as a string.
</P
><P
>Two SqlValues are considered to be equal if one of these hold (first one that
is true holds; if none are true, they are not equal):
 * Both are NULL
 * Both represent the same type and the encapsulated values are equal
 * The values of each, when converted to a string, are equal. 
</P
></TD
></TR
><TR
><TD CLASS="section4"
>Constructors</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlString"
></A
><B
>SqlString</B
> String</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlWord32"
></A
><B
>SqlWord32</B
> Word32</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlWord64"
></A
><B
>SqlWord64</B
> Word64</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlInt32"
></A
><B
>SqlInt32</B
> Int32</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlInt64"
></A
><B
>SqlInt64</B
> Int64</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlInteger"
></A
><B
>SqlInteger</B
> Integer</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlChar"
></A
><B
>SqlChar</B
> Char</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlBool"
></A
><B
>SqlBool</B
> Bool</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlDouble"
></A
><B
>SqlDouble</B
> Double</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlRational"
></A
><B
>SqlRational</B
> Rational</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlEpochTime"
></A
><B
>SqlEpochTime</B
> Integer</TD
><TD CLASS="rdoc"
>Representation of ClockTime or CalendarTime
</TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlTimeDiff"
></A
><B
>SqlTimeDiff</B
> Integer</TD
><TD CLASS="rdoc"
>Representation of TimeDiff
</TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlNull"
></A
><B
>SqlNull</B
></TD
><TD CLASS="rdoc"
>NULL in SQL or Nothing in Haskell
</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:SqlValue')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:SqlValue" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
>Eq <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TD
></TR
><TR
><TD CLASS="decl"
>Show <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="5"
>Database Connections
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
> <A NAME="t%3AConnection"
></A
><B
>Connection</B
> </TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><P
>Main database handle object.
</P
><P
>A <TT
><A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
></TT
> object is created by specific functions in the module for an
individual database.  That is, the connect function -- which creates
this object -- is not standardized through the HDBC interface.
</P
><P
>A connection is closed by a call to <TT
><A HREF="Database-HDBC.html#v%3Adisconnect"
>disconnect</A
></TT
>.
</P
><P
>A call to <TT
><A HREF="Database-HDBC.html#v%3Acommit"
>commit</A
></TT
> is required to make sure that your changes get committed
to the database.  In other words, HDBC has <EM
>no support for autocommit</EM
>, which
we consider an outdated notion.
</P
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3Adisconnect"
></A
><B
>disconnect</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO ()</TD
></TR
><TR
><TD CLASS="doc"
><P
>Disconnect from the remote database.
</P
><P
>You do not need to explicitly close a Connection object, but you may do so if
you so desire.  If you don't, the object will disconnect from the database
in a sane way when it is garbage-collected.  However, a disconnection may
raise an error, so you are encouraged to explicitly call <TT
><A HREF="Database-HDBC.html#v%3Adisconnect"
>disconnect</A
></TT
>.  Also,
garbage collection may not run when the program terminates, and some databases
really like an explicit disconnect.
</P
><P
>So, bottom line is, you're best off calling <TT
><A HREF="Database-HDBC.html#v%3Adisconnect"
>disconnect</A
></TT
> directly, but the
world won't end if you forget.
</P
><P
>This function discards any data not committed already.  Database driver
implementators should explicitly call <TT
><A HREF="Database-HDBC.html#v%3Arollback"
>rollback</A
></TT
> if their databases don't
do this automatically on disconnect.
</P
><P
>Bad Things (TM) could happen if you call this while you have <TT
><A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
></TT
>s 
active.  In more precise language, the results in such situations are undefined
and vary by database.  So don't do it.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3Aclone"
></A
><B
>clone</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Create a new <TT
><A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
></TT
> object, pointed at the same
                   server as this object is.  This will generally establish
                   a separate physical connection.
</P
><P
>When you wish to establish multiple connections to a single
                   server, the correct way to do so is to establish the
                   first connection with the driver-specific connection
                   function, and then clone it for each additional connection.
</P
><P
>This can be important when a database doesn't provide
                   much thread support itself, and the HDBC driver module
                   must serialize access to a particular database.
</P
><P
>This can also be a handy utility function whenever you
                   need a separate connection to whatever database you are
                   connected to already. 
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="6"
>Preparing Queries
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3Arun"
></A
><B
>run</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String -&gt; [<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>] -&gt; IO Integer</TD
></TR
><TR
><TD CLASS="doc"
>Execute a single SQL query.  Returns the number
                   of rows modified (see <TT
><A HREF="Database-HDBC.html#v%3Aexecute"
>execute</A
></TT
> for details).
                   The second parameter is a list
                   of replacement values, if any. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AsRun"
></A
><B
>sRun</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String -&gt; [Maybe String] -&gt; IO Integer</TD
></TR
><TR
><TD CLASS="doc"
>Like <TT
><A HREF="Database-HDBC.html#v%3Arun"
>run</A
></TT
>, but take a list of Maybe Strings instead of <TT
><A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TT
>s. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3Aprepare"
></A
><B
>prepare</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String -&gt; IO <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Prepares a statement for execution. 
</P
><P
>Question marks in the statement will be replaced by
                   positional parameters in a later call to <TT
><A HREF="Database-HDBC.html#v%3Aexecute"
>execute</A
></TT
>.
</P
><P
>Please note that, depending on the database
                   and the driver, errors in your SQL may be raised
                   either here or by <TT
><A HREF="Database-HDBC.html#v%3Aexecute"
>execute</A
></TT
>.  Make sure you
                   handle exceptions both places if necessary. 
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AquickQuery"
></A
><B
>quickQuery</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String -&gt; [<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>] -&gt; IO [[<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>]]</TD
></TR
><TR
><TD CLASS="doc"
>A quick way to do a query.  Similar to preparing, executing, and
then calling <TT
><A HREF="Database-HDBC.html#v%3AfetchAllRows"
>fetchAllRows</A
></TT
> on a statement. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="7"
>Transaction Handling
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="doc"
><P
>This section concerns itself with writing (updating) a database.
</P
><P
>In HDBC, as with many RDBMS implementations, every write to the
database occurs within a transaction.  No changes are visible (outside
the current transaction) until a commit operation occurs, in which
case all changes since the transaction started are atomically
committed.  Also, there is a rollback operation that can undo all
changes since the transaction started.
</P
><P
>HDBC does everything within a transaction.  A transaction is implicitly entered
when a connection to a database is established, and a transaction is
implicitly entered after each call to <TT
><A HREF="Database-HDBC.html#v%3Acommit"
>commit</A
></TT
> or <TT
><A HREF="Database-HDBC.html#v%3Arollback"
>rollback</A
></TT
> as well.
</P
><P
>The practical effect of this is that you must call <TT
><A HREF="Database-HDBC.html#v%3Acommit"
>commit</A
></TT
> after making
changes to a database in order for those changes to become visible.  You don't
have to call <TT
><A HREF="Database-HDBC.html#v%3Acommit"
>commit</A
></TT
> after <EM
>every</EM
> change, just after a batch of them.
</P
><P
>(Exceptions exist for databases that don't offer a high level of transaction
isolation; but you should always play it safe and commit anyway.)
</P
><P
>Database developers will also be experienced with the atomicity benefits
of transactions, an explanation of which is outside the scope of this manual.
</P
><P
>Errors occuring at the database level can leave a transaction in an
indeterminate state, depending on the database.  Some databases will
refuse all queries until the next <TT
><A HREF="Database-HDBC.html#v%3Acommit"
>commit</A
></TT
> or <TT
><A HREF="Database-HDBC.html#v%3Arollback"
>rollback</A
></TT
>.  The safe thing
to do is to issue a <TT
><A HREF="Database-HDBC.html#v%3Acommit"
>commit</A
></TT
> or <TT
><A HREF="Database-HDBC.html#v%3Arollback"
>rollback</A
></TT
> after trapping any <TT
><A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
></TT
>.
Alternatively, you could use <TT
><A HREF="Database-HDBC.html#v%3AwithTransaction"
>withTransaction</A
></TT
>, which will automatically
handle this detail for you.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3Acommit"
></A
><B
>commit</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO ()</TD
></TR
><TR
><TD CLASS="doc"
><P
>Commit any pending data to the database.
</P
><P
>Required to make any changes take effect. 
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3Arollback"
></A
><B
>rollback</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO ()</TD
></TR
><TR
><TD CLASS="doc"
>Roll back to the state the database was in prior to the
                   last <TT
><A HREF="Database-HDBC.html#v%3Acommit"
>commit</A
></TT
> or <TT
><A HREF="Database-HDBC.html#v%3Arollback"
>rollback</A
></TT
>. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AwithTransaction"
></A
><B
>withTransaction</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; (<A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO a) -&gt; IO a</TD
></TR
><TR
><TD CLASS="doc"
><P
>Execute some code.  If any uncaught exception occurs, run
<TT
><A HREF="Database-HDBC.html#v%3Arollback"
>rollback</A
></TT
> and re-raise it.  Otherwise, run <TT
><A HREF="Database-HDBC.html#v%3Acommit"
>commit</A
></TT
> and return.
</P
><P
>This function, therefore, encapsulates the logical property that a transaction
is all about: all or nothing.
</P
><P
>The <TT
><A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
></TT
> object passed in is passed directly to the specified
function as a convenience.
</P
><P
>This function traps <EM
>all</EM
> uncaught exceptions, not just SqlErrors.  Therefore,
you will get a rollback for any exception that you don't handle.  That's
probably what you want anyway.
</P
><P
>Since all operations in HDBC are done in a transaction, this function doesn't
issue an explicit &quot;begin&quot; to the server.  You should ideally have
called <TT
><A HREF="Database-HDBC.html#v%3Acommit"
>commit</A
></TT
> or <TT
><A HREF="Database-HDBC.html#v%3Arollback"
>rollback</A
></TT
> before
calling this function.  If you haven't, this function will commit or rollback
more than just the changes made in the included action.
</P
><P
>If there was an error while running <TT
><A HREF="Database-HDBC.html#v%3Arollback"
>rollback</A
></TT
>, this error will not be
reported since the original exception will be propogated back.  (You'd probably
like to know about the root cause for all of this anyway.)  Feedback
on this behavior is solicited.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="8"
>Connection Inquiries
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AhdbcDriverName"
></A
><B
>hdbcDriverName</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="doc"
>The name of the HDBC driver module for this connection.
                   Ideally would be the same as the database name portion
                   of the Cabal package name.  For instance, &quot;sqlite3&quot;
                   or &quot;odbc&quot;.  This is the layer that is bound most
                   tightly to HDBC. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AhdbcClientVer"
></A
><B
>hdbcClientVer</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="doc"
>The version of the C (or whatever) client library
                   that the HDBC driver module is bound to.  The meaning
                   of this is driver-specific.  For an ODBC or similar
                   proxying driver, this should be the version of the
                   ODBC library, not the eventual DB client driver. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AproxiedClientName"
></A
><B
>proxiedClientName</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="doc"
>In the case of a system such as ODBC, the name of
                   the database client/server in use, if available.
                   For others,
                   identical to <TT
><A HREF="Database-HDBC.html#v%3AhdbcDriverName"
>hdbcDriverName</A
></TT
>. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AproxiedClientVer"
></A
><B
>proxiedClientVer</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="doc"
>In the case of a system such as ODBC, the version of
                   the database client in use, if available.  For others,
                   identical to <TT
><A HREF="Database-HDBC.html#v%3AhdbcClientVer"
>hdbcClientVer</A
></TT
>. This is the next layer
                   out past the HDBC driver. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AdbServerVer"
></A
><B
>dbServerVer</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="doc"
>The version of the database server, if available. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AdbTransactionSupport"
></A
><B
>dbTransactionSupport</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; Bool</TD
></TR
><TR
><TD CLASS="doc"
>Whether or not the current database supports transactions.
                   If False, then <TT
><A HREF="Database-HDBC.html#v%3Acommit"
>commit</A
></TT
> and <TT
><A HREF="Database-HDBC.html#v%3Arollback"
>rollback</A
></TT
> should be expected
                   to raise errors. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AgetTables"
></A
><B
>getTables</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; IO [String]</TD
></TR
><TR
><TD CLASS="doc"
><P
>The names of all tables accessible by the current
                   connection, excluding special meta-tables (system tables).
</P
><P
>You should expect this to be returned in the same manner
                   as a result from <TT
><A HREF="Database-HDBC.html#v%3AfetchAllRows"
>fetchAllRows</A
></TT
>.
</P
><P
>All results should be converted to lowercase for you
                   before you see them.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AdescribeTable"
></A
><B
>describeTable</B
> :: <A HREF="Database-HDBC.html#t%3AConnection"
>Connection</A
> -&gt; String -&gt; IO [(String, <A HREF="Database-HDBC-ColTypes.html#t%3ASqlColDesc"
>SqlColDesc</A
>)]</TD
></TR
><TR
><TD CLASS="doc"
><P
>Obtain information about the columns in a specific
                   table.  The String in the result
                   set is the column name.
</P
><P
>You should expect this to be returned in the same manner
                   as a result from <TT
><A HREF="Database-HDBC.html#v%3AfetchAllRows"
>fetchAllRows</A
></TT
>.
</P
><P
>All results should be converted to lowercase for you
                   before you see them.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="9"
>Statements
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
> <A NAME="t%3AStatement"
></A
><B
>Statement</B
> </TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="10"
>Execution
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3Aexecute"
></A
><B
>execute</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; [<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>] -&gt; IO Integer</TD
></TR
><TR
><TD CLASS="doc"
><P
>Execute the prepared statement, passing in the given positional
        parameters (that should take the place of the question marks
        in the call to <TT
><A HREF="Database-HDBC.html#v%3Aprepare"
>prepare</A
></TT
>).
</P
><P
>For non-SELECT queries, the return value is the number of
        rows modified, if known.  If no rows were modified, you get 0.
        If the value is unknown, you get -1.  All current HDBC drivers
        support this function and should never return -1.
</P
><P
>For SELECT queries, you will always get 0.
</P
><P
>This function should automatically call finish() to finish the previous
        execution, if necessary.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AsExecute"
></A
><B
>sExecute</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; [Maybe String] -&gt; IO Integer</TD
></TR
><TR
><TD CLASS="doc"
>Like <TT
><A HREF="Database-HDBC.html#v%3Aexecute"
>execute</A
></TT
>, but take a list of Maybe Strings instead of
   <TT
><A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TT
>s. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AexecuteMany"
></A
><B
>executeMany</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; [[<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>]] -&gt; IO ()</TD
></TR
><TR
><TD CLASS="doc"
><P
>Execute the query with many rows. 
        The return value is the return value from the final row 
        as if you had called <TT
><A HREF="Database-HDBC.html#v%3Aexecute"
>execute</A
></TT
> on it.
</P
><P
>Due to optimizations that are possible due to different
        databases and driver designs, this can often be significantly
        faster than using <TT
><A HREF="Database-HDBC.html#v%3Aexecute"
>execute</A
></TT
> multiple times since queries
        need to be compiled only once.
</P
><P
>This is most useful for non-SELECT statements. 
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AsExecuteMany"
></A
><B
>sExecuteMany</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; [[Maybe String]] -&gt; IO ()</TD
></TR
><TR
><TD CLASS="doc"
>Like <TT
><A HREF="Database-HDBC.html#v%3AexecuteMany"
>executeMany</A
></TT
>, but take a list of Maybe Strings instead of
   <TT
><A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TT
>s. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="11"
>Fetching Results
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AfetchRow"
></A
><B
>fetchRow</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO (Maybe [<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>])</TD
></TR
><TR
><TD CLASS="doc"
>Fetches one row from the DB.  Returns Nothing if there
        are no more rows.  Will automatically call <TT
><A HREF="Database-HDBC.html#v%3Afinish"
>finish</A
></TT
> when
        the last row is read. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AfetchRowAL"
></A
><B
>fetchRowAL</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO (Maybe [(String, <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>)])</TD
></TR
><TR
><TD CLASS="doc"
><P
>Like <TT
><A HREF="Database-HDBC.html#v%3AfetchRow"
>fetchRow</A
></TT
>, but instead of returning a list, return an association
list from column name to value.
</P
><P
>The keys of the column names are lowercase versions of the data returned
by <TT
><A HREF="Database-HDBC.html#v%3AgetColumnNames"
>getColumnNames</A
></TT
>.  Please heed the warnings there.  Additionally,
results are undefined if multiple columns are returned with identical names.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AfetchRowMap"
></A
><B
>fetchRowMap</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO (Maybe (Map String <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>))</TD
></TR
><TR
><TD CLASS="doc"
>Similar to <TT
><A HREF="Database-HDBC.html#v%3AfetchRowAL"
>fetchRowAL</A
></TT
>, but return a Map instead of an association list.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AsFetchRow"
></A
><B
>sFetchRow</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO (Maybe [Maybe String])</TD
></TR
><TR
><TD CLASS="doc"
>Like <TT
><A HREF="Database-HDBC.html#v%3AfetchRow"
>fetchRow</A
></TT
>, but return a list of Maybe Strings instead of
   <TT
><A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TT
>s. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AfetchAllRows"
></A
><B
>fetchAllRows</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [[<A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>]]</TD
></TR
><TR
><TD CLASS="doc"
><P
>Lazily fetch all rows from an executed <TT
><A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
></TT
>.
</P
><P
>You can think of this as hGetContents applied to a database result set.
</P
><P
>The result of this is a lazy list, and each new row will be read, lazily, from
the database as the list is processed.
</P
><P
>When you have exhausted the list, the <TT
><A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
></TT
> will be <TT
><A HREF="Database-HDBC.html#v%3Afinish"
>finish</A
></TT
>ed.
</P
><P
>Please note that the careless use of this function can lead to some unpleasant
behavior.  In particular, if you have not consumed the entire list, then
attempt to <TT
><A HREF="Database-HDBC.html#v%3Afinish"
>finish</A
></TT
> or re-execute the statement, and then attempt to consume
more elements from the list, the result will almost certainly not be what
you want.
</P
><P
>But then, similar caveats apply with hGetContents.
</P
><P
>Bottom line: this is a very convenient abstraction; use it wisely.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AfetchAllRowsAL"
></A
><B
>fetchAllRowsAL</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [[(String, <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>)]]</TD
></TR
><TR
><TD CLASS="doc"
><P
>Like <TT
><A HREF="Database-HDBC.html#v%3AfetchAllRows"
>fetchAllRows</A
></TT
>, but instead of returning a list for each
row, return an association list for each row, from column name to value.
</P
><P
>See <TT
><A HREF="Database-HDBC.html#v%3AfetchRowAL"
>fetchRowAL</A
></TT
> for more details. 
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AfetchAllRowsMap"
></A
><B
>fetchAllRowsMap</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [Map String <A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
>]</TD
></TR
><TR
><TD CLASS="doc"
>Like <TT
><A HREF="Database-HDBC.html#v%3AfetchAllRowsAL"
>fetchAllRowsAL</A
></TT
>, but return a list of Maps instead of a list of
association lists. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AsFetchAllRows"
></A
><B
>sFetchAllRows</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [[Maybe String]]</TD
></TR
><TR
><TD CLASS="doc"
>Like <TT
><A HREF="Database-HDBC.html#v%3AfetchAllRows"
>fetchAllRows</A
></TT
>, but return Maybe Strings instead of <TT
><A HREF="Database-HDBC.html#t%3ASqlValue"
>SqlValue</A
></TT
>s. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AgetColumnNames"
></A
><B
>getColumnNames</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [String]</TD
></TR
><TR
><TD CLASS="doc"
><P
>Returns a list of the column names in the result.
        For maximum portability, you should not assume that
        information is available until after an <TT
><A HREF="Database-HDBC.html#v%3Aexecute"
>execute</A
></TT
> function
        has been run.
</P
><P
>Information is returned here directly as returned
        by the underlying database layer.  Note that different
        databases have different rules about capitalization
        of return values and about representation of names
        of columns that are not simple columns.  For this reason,
        it is suggested that you treat this information for
        display purposes only.  Failing that, you should convert
        to lower (or upper) case, and use <TT
>AS</TT
> clauses for
        anything other than simple columns.
</P
><P
>A simple getColumnNames implementation could simply
        apply <TT
>map fst</TT
> to the return value of <TT
><A HREF="Database-HDBC.html#v%3AdescribeResult"
>describeResult</A
></TT
>.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="12"
>Statement Inquires
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AdescribeResult"
></A
><B
>describeResult</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO [(String, <A HREF="Database-HDBC-ColTypes.html#t%3ASqlColDesc"
>SqlColDesc</A
>)]</TD
></TR
><TR
><TD CLASS="doc"
><P
>Obtain information about the columns in the result set.
          Must be run only after <TT
><A HREF="Database-HDBC.html#v%3Aexecute"
>execute</A
></TT
>.  The String in the result
          set is the column name.
</P
><P
>You should expect this to be returned in the same manner
          as a result from <TT
><A HREF="Database-HDBC.html#v%3AfetchAllRows"
>fetchAllRows</A
></TT
>.
</P
><P
>All results should be converted to lowercase for you
          before you see them.
</P
><P
>Please see caveats under <TT
><A HREF="Database-HDBC.html#v%3AgetColumnNames"
>getColumnNames</A
></TT
> for information
          on the column name field here.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section2"
><A NAME="13"
>Miscellaneous
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3Afinish"
></A
><B
>finish</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; IO ()</TD
></TR
><TR
><TD CLASS="doc"
>Abort a query in progress -- usually not needed. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AoriginalQuery"
></A
><B
>originalQuery</B
> :: <A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
> -&gt; String</TD
></TR
><TR
><TD CLASS="doc"
>The original query that this <TT
><A HREF="Database-HDBC.html#t%3AStatement"
>Statement</A
></TT
> was prepared
          with. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="14"
>Exceptions
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
> <A NAME="t%3ASqlError"
></A
><B
>SqlError</B
> </TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><P
>The main HDBC exception object.  As much information as possible
is passed from the database through to the application through this object.
</P
><P
>Errors generated in the Haskell layer will have seNativeError set to -1.
</P
></TD
></TR
><TR
><TD CLASS="section4"
>Constructors</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="5" CELLPADDING="0"
><TR
><TD CLASS="arg"
><A NAME="v%3ASqlError"
></A
><B
>SqlError</B
></TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="body" COLSPAN="2"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="arg"
><A NAME="v%3AseState"
></A
><B
>seState</B
> :: String</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3AseNativeError"
></A
><B
>seNativeError</B
> :: Int</TD
><TD CLASS="rdoc"
></TD
></TR
><TR
><TD CLASS="arg"
><A NAME="v%3AseErrorMsg"
></A
><B
>seErrorMsg</B
> :: String</TD
><TD CLASS="rdoc"
></TD
></TR
></TABLE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:SqlError')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:SqlError" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
>Eq <A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
></TD
></TR
><TR
><TD CLASS="decl"
>Read <A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
></TD
></TR
><TR
><TD CLASS="decl"
>Show <A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
></TD
></TR
><TR
><TD CLASS="decl"
>Typeable <A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AcatchSql"
></A
><B
>catchSql</B
> :: IO a -&gt; (<A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
> -&gt; IO a) -&gt; IO a</TD
></TR
><TR
><TD CLASS="doc"
><P
>Execute the given IO action.
</P
><P
>If it raises a <TT
><A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
></TT
>, then execute the supplied handler and return its
return value.  Otherwise, proceed as normal. 
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AhandleSql"
></A
><B
>handleSql</B
> :: (<A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
> -&gt; IO a) -&gt; IO a -&gt; IO a</TD
></TR
><TR
><TD CLASS="doc"
>Like <TT
><A HREF="Database-HDBC.html#v%3AcatchSql"
>catchSql</A
></TT
>, with the order of arguments reversed. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AsqlExceptions"
></A
><B
>sqlExceptions</B
> :: Exception -&gt; Maybe <A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
></TD
></TR
><TR
><TD CLASS="doc"
>Given an Exception, return Just SqlError if it was an SqlError, or Nothing
otherwise. Useful with functions like catchJust. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3AhandleSqlError"
></A
><B
>handleSqlError</B
> :: IO a -&gt; IO a</TD
></TR
><TR
><TD CLASS="doc"
>Catches <TT
><A HREF="Database-HDBC.html#t%3ASqlError"
>SqlError</A
></TT
>s, and re-raises them as IO errors with fail.
Useful if you don't care to catch SQL errors, but want to see a sane
error message if one happens.  One would often use this as a high-level
wrapper around SQL calls. 
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="15"
>Column Types
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="doc"
>These are defined in <A HREF="Database-HDBC-ColTypes.html"
>Database.HDBC.ColTypes</A
> but are
 available to programs importing <A HREF="Database-HDBC.html"
>Database.HDBC</A
> by default as well.
 See <A HREF="Database-HDBC-ColTypes.html"
>Database.HDBC.ColTypes</A
> for documentation.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
>module <A HREF="Database-HDBC-ColTypes.html"
>Database.HDBC.ColTypes</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="16"
>Threading
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="doc"
><P
>FIXME: this is draft information
</P
><P
>Thread support in a generalized interface such as HDBC can be complicated
because support for threading varies across database interfaces.
</P
><P
>However, applications using HDBC should be able to rely upon at least a few
basic guarantees:
</P
><UL
><LI
> The HDBC modules may freely be imported and used across all threads.
</LI
><LI
> HDBC modules may also freely share database connections and statements;
   the database or HDBC driver will be responsible for locking if necessary.
</LI
></UL
><P
>I use &quot;share&quot; in the same sense as Python's DB-API: multiple threads may use
the resource without wrapping it in any lock.
</P
><P
>However, there are some caveats to the above:
</P
><UL
><LI
> Not all databases support more than one active statement for a single
   connection.  Therefore, for maximum portability, you should use
   a different connection to the database for each simultaneous query you
   wish to use.
   FIXME: describe when a statement is active.
</LI
><LI
> Not all databases may support the level of multithreading described above.
   For those that don't, safe access will be restriced in the HDBC driver
   by using locks.  Therefore, you can write portable code, but you 
   only get real multithreading when databases really support it.
   Details of thread support should be documented in the HDBC
   driver for each specific database.
</LI
></UL
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
><A NAME="17"
>Copyright and License
</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="doc"
><P
>Copyright (C) 2005-2006 John Goerzen <A HREF="jgoerzen@complete.org"
>jgoerzen@complete.org</A
>
</P
><P
>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
</P
><P
>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
</P
><P
>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
</P
><P
>Please see COPYING in the source distribution for the full license.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="botbar"
>Produced by <A HREF="http://www.haskell.org/haddock/"
>Haddock</A
> version 0.7</TD
></TR
></TABLE
></BODY
></HTML
>
